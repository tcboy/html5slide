/****** 2015-03-02 晋级答辩提纲 ******/

提纲:
1. 自我介绍
	* 
2. 工作概述
	1> IOS UID转换
	2> Android反作弊相关
		反作弊规则
3. IOS UID转换
	1> 为什么要进行IOS的UID转换
		* IOS UID历史发展
			2010-12 IMEI
			2013-05 -> MAC
			2013-06 -> AID
			2013-09 -> IID(IDFV)
			版本升级导致无法将各个时期同一个用户关联起来
		* 业务数据分析的需求
			需要根据设备对同一个用户进行历史数据的分析
		* 新激活用户的判断
	2> 之前的解决方案
		* 使用IMEI|IID|MAC|GID进行串联生成唯一的新UID
		* 问题: 重复, 无效的ID导致整个关联关系混乱, 大量重复MAC地址, GID使得大量不同设备关联到同一个新的UID上
		* 导致统计新激活, 计算业务模型出现错误 
	3> 改进的目标
		* 关联IMEI|IID|MAC|GID|AID串联生成唯一的新UID
		* 找出不同设备的重复ID, 标记为无效ID
		* 使用新UID替换现有的UID
		* 对外提供UID与各个设备ID的转换查询
	4> 新的解决方案
		* 记录XID -> DID之间的对应关系
			包含依赖ID，访问时间，请求信息
		* 记录DID所对应的XID历史
		* 记录无效的XID
		* 根据历史关系，判断关联关系是否异常，若关联关系异常，则将异常ID标记出来并重新建立其余相关XID的关联关系
		* 异常检测
			同一请求中多个xid对应到不同的did时，优先级低的xid异常
			根据gid查到的对应关系创建时间记为E，请求中的日志时间时间记为C，根据对应关系找到其它gid的创建时间记为L，若存在满足不等式E<L<C的gid对应关系，则当前gid对应关系的依赖rid异常
	5> 困难点
		* 存储容器选择 (读写速度，分布式（一致性|可靠性））
		* 大量历史数据的重新清洗(每日大概多少PV多少UV)　共多少G
		* 
	6> 为什么TAIR
		* TAIR介绍&架构
		* TAIR与其他几种主流缓存的速度与功能对比
	7> 解决方案实现
		* 使用MapReduce程序在Hadoop上进行清洗计算
		* 并行计算乐观锁
	8> 测试
		* 速度测试
		* 准确性测试
		* 完整性测试
	9> 改进之后的效果
		* 前后新激活用户的对比
		* 
	10> 后期辅助工作
		* 完整系统架构
		* 新用户实时入库 qmq
		* rpc查询接口 dubbo

4. 总结

5. QA
	
